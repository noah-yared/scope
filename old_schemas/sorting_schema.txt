# --- Sorting Thought Schema ---

sorting_thought_schema = {
    "Step Metadata": {
        "Step ID": None,
        "Algorithm / Sorting Strategy": "",  # e.g., "Insertion", "Bubble", "Heap", "Quick"
        "Operation Type": "",  # e.g., "compare", "swap", "insert", "partition"
        "Explanation": "",  # Natural language reasoning for this step
    },

    "Core State Representation": {
        "Input Representation": {
            "type": "list[Any]",
            "description": "Snapshot of the array or list being sorted.",
            # Example: arr = [5, 3, 1, 4]
        },
        "Current Stage": {
            "type": "list[Any] | dict[str, Any]",
            "description": "Internal representation of how the input is progressing (e.g., heapified array, partitioned sublists).",
        },
        "Boundary of Sorted Region": {
            "type": "list[int] | tuple[int, int]",
            "description": "Track what section of the input is already sorted (e.g., indices [0:i]).",
        },
        "Remaining": {
            "type": "list[int] | tuple[int, int]",
            "description": "Track what part of the input still needs sorting.",
        },
        "Termination Condition": {
            "type": "bool | str",
            "description": "Boolean or textual stopping condition that signals when sorting is complete.",
            # Example: "remaining is empty"
        },
    },

    "Focused Action": {
        "Current Element Focus": {
            "type": "Any | int | float | str",
            "description": "Element and index currently being compared, inserted, or swapped.",
            # Example: current = arr[i]
        },
        "Comparison Target(s)": {
            "type": "Any | list[Any]",
            "description": "Element(s) or region of input that the current element is being compared or sorted against.",
            # Example: arr[i-1] or arr[j:]
        },
        "Operation Type": {
            "type": "str",
            "description": "Defines what operation should be performed with the current element and comparison targets.",
            # Example: 'compare', 'swap', 'insert', 'partition'
        },
        "Reasoning / Action Plan": {
            "type": "str",
            "description": "Describe the decision rule and intended manipulation of elements.",
            # Example: 'swap if current < target'
        },
    }
}

# --- Core Iteration Process ---
# This runnable block represents a general reasoning-based iteration process
# for sorting using thought schema logic. It demonstrates how reasoning steps
# could be executed dynamically without being tied to a specific algorithm.

input_state = [5, 3, 1, 4]
print("Initial State:", input_state)

for i in range(len(input_state)):
    current = input_state[i]             # Current Element Focus
    comparison_targets = input_state[:i] # Comparison Targets
    operation_type = "compare"           # Operation Type

    # Reasoning / Action Plan:
    # If current element is smaller than any of its previous elements,
    # reposition it by swapping backward (insertion-like behavior).
    for j in range(i - 1, -1, -1):
        if input_state[j] > input_state[j + 1]:
            # Swap operation
            input_state[j], input_state[j + 1] = input_state[j + 1], input_state[j]
            operation_type = "swap"
        else:
            # Already ordered correctly relative to target
            break
